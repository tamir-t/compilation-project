/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.declarations.*;
import ast.expressions.*;
import ast.expressions.func.*;
import ast.statements.*;
import ast.variables.*;
import ast.*;
import ast.expressions.AST_EXP_BINOP.Op;

parser code 
{:
	public Lexer lexer;
    public int line;
	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
	    line = lexer.getLine();
		throw new IllegalStateException(message + " " + info);
	}
:}

/*************/
/* TERMINALS */
/*************/
  /* other 1 */
 terminal SEMICOLON, COMMENT;
  /* keywords */
 terminal ARRAY, CLASS, EXTENDS, RETURN, WHILE, IF, NEW;
  /* separators */
 terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
  /* literals */
 terminal NIL;
  /* operators */
 terminal PLUS, MINUS, TIMES, DIVIDE,LT, GT, EQ, ASSIGN, COMMA, DOT;

terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/

// program
non terminal AST_PROGRAM program;

 // dec
non terminal AST_DEC dec;
non terminal AST_DEC_LIST decList;

non terminal AST_DEC_VAR varDec;
non terminal AST_DEC_FUNC funcDec;
non terminal AST_DEC_CLASS classDec;
non terminal AST_DEC_ARRAY arrayDec;

// exp
non terminal AST_EXP exp;
non terminal AST_CALLABLE_VAR_CONT varCont;
non terminal AST_CALLABLE_VAR_CONT callVarCont;
// new exp
non terminal AST_NEW_EXP newExp;

// field
non terminal AST_DEC cField;
non terminal AST_DEC_LIST cFieldList;

// statement
non terminal AST_STMT stmt;
non terminal AST_STMT_LIST stmtList;
non terminal AST_ID_LIST idList;
non terminal AST_EXP_LIST expList;

// variables
non terminal AST_VAR var;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left EQ;
precedence left LT,GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left DOT;
/************************/
/* START WITH: program */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/
program     ::=     decList:l                                                               {: RESULT = new AST_PROGRAM(l); :}
			;

decList     ::=     dec:d decList:l		                                                    {: RESULT = new AST_DEC_LIST(d,l); :}
					| dec:d				                                                    {: RESULT = new AST_DEC_LIST(d,null); :}
			;

//region Decleartions
dec         ::=     varDec:d                                                                {: RESULT = d; :}
					| funcDec:d                                                             {: RESULT = d; :}
					| classDec:d                                                            {: RESULT = d; :}
					| arrayDec:d                                                            {: RESULT = d; :}
			;

varDec      ::=     ID:type ID:name SEMICOLON                                               {: RESULT = new AST_DEC_VAR_EXP(type, name); :}
					| ID:type ID:name ASSIGN exp:e SEMICOLON                                {: RESULT = new AST_DEC_VAR_EXP(type, name, e); :}
					| ID:type ID:name ASSIGN newExp:e SEMICOLON                             {: RESULT = new AST_DEC_VAR_NEW(type, name, e); :}
			;

funcDec     ::=     ID:type ID:name LPAREN RPAREN LBRACE stmtList:s RBRACE                  {: RESULT = new AST_DEC_FUNC(type, name, s); :}
					| ID:type ID:name LPAREN idList:i RPAREN LBRACE stmtList:s RBRACE       {: RESULT = new AST_DEC_FUNC(type, name, s, i); :}
			;

classDec    ::=     CLASS ID:name LBRACE cFieldList:l RBRACE                                {: RESULT = new AST_DEC_CLASS(name, l); :}
				    | CLASS ID:name EXTENDS ID:parent LBRACE cFieldList:l RBRACE            {: RESULT = new AST_DEC_CLASS(name, l, parent); :}
			;

arrayDec    ::=     ARRAY ID:name EQ ID:type LBRACK RBRACK                                  {: RESULT = new AST_DEC_ARRAY(type, name); :}
			;
// endregion

// region expressions
exp			::=		ID:name	callVarCont:c							                        {: RESULT = AST_CALLABLE_VAR_CONT.create(name, c); :}
                    | ID:name                                                               {: RESULT = AST_CALLABLE_VAR_CONT.create(name, null); :}
					| LPAREN exp:e RPAREN				                                    {: RESULT = e; :}
					| exp:e1 EQ exp:e2				                                        {: RESULT = new AST_EXP_BINOP(e1, e2, Op.EQ); :}
					| exp:e1 LT exp:e2				                                        {: RESULT = new AST_EXP_BINOP(e1, e2, Op.LT); :}
					| exp:e1 GT exp:e2				                                        {: RESULT = new AST_EXP_BINOP(e1, e2, Op.GT); :}
					| exp:e1 PLUS exp:e2				                                    {: RESULT = new AST_EXP_BINOP(e1, e2, Op.Plus); :}
					| exp:e1 MINUS exp:e2				                                    {: RESULT = new AST_EXP_BINOP(e1, e2, Op.Minus); :}
                    | exp:e1 TIMES exp:e2				                                    {: RESULT = new AST_EXP_BINOP(e1, e2, Op.Times); :}
					| exp:e1 DIVIDE exp:e2				                                    {: RESULT = new AST_EXP_BINOP(e1, e2, Op.Divide); :}
		            | MINUS INT:i								                            {: RESULT = new AST_EXP_INT(i, false); :}
					| INT:i								                                    {: RESULT = new AST_EXP_INT(i); :}
					| NIL								                                    {: RESULT = new AST_EXP_NIL(); :}
					| STRING:s							                                    {: RESULT = new AST_EXP_STRING(s); :}
		    ;

callVarCont ::=     varCont:c                                                               {: RESULT = c; :}
                    | LPAREN RPAREN                                                         {: RESULT = new AST_CALLABLE_VAR_CONT_FUNC(null); :}
                    | LPAREN expList:e RPAREN                                               {: RESULT = new AST_CALLABLE_VAR_CONT_FUNC(e); :}
            ;

varCont     ::=     LBRACK exp:e RBRACK varCont:c                                           {: RESULT = new AST_CALLABLE_VAR_CONT_SUBSCRIPT(c, e); :}
                    | LBRACK exp:e RBRACK                                                   {: RESULT = new AST_CALLABLE_VAR_CONT_SUBSCRIPT(null, e); :}
                    | DOT ID:name callVarCont:c                                             {: RESULT = new AST_CALLABLE_VAR_CONT_FIELD(c, name); :}
                    | DOT ID:name                                                           {: RESULT = new AST_CALLABLE_VAR_CONT_FIELD(null, name); :}
            ;


expList	    ::=		exp:e COMMA expList:l		                                            {: RESULT = new AST_EXP_LIST(e,l); :}
					| exp:e				                                                    {: RESULT = new AST_EXP_LIST(e,null); :}
			;

newExp      ::=     NEW ID:name                                                             {: RESULT = new AST_NEW_EXP_JUSTID(name); :}
                    | NEW ID:name LBRACK exp:e RBRACK                                       {: RESULT = new AST_NEW_EXP_SUBSCRIPT(name, e); :}
            ;
// endregion

// region variable
var			::=		ID:name								                                    {: RESULT = new AST_VAR_SIMPLE(name); :}
					| var:v DOT ID:fieldName			                                    {: RESULT = new AST_VAR_FIELD(v,fieldName); :}
					| var:v LBRACK exp:e RBRACK			                                    {: RESULT = new AST_VAR_SUBSCRIPT(v,e); :}
			;
// endregion

// region statements
stmtList	::=		stmt:s stmtList:l		                                                {: RESULT = new AST_STMT_LIST(s,l); :}
					| stmt:s				                                                {: RESULT = new AST_STMT_LIST(s,null); :}
			;

stmt		::=		varDec:d                                                                {: RESULT = new AST_STMT_VAR_DEC(d); :}
                    | var:v ASSIGN exp:e SEMICOLON								            {: RESULT = new AST_STMT_ASSIGN(v,e); :}
                    | var:v ASSIGN newExp:e SEMICOLON								        {: RESULT = new AST_STMT_ASSIGN_NEW(v,e); :}
                    | RETURN SEMICOLON                                                      {: RESULT = new AST_STMT_RETURN(); :}
                    | RETURN exp:e SEMICOLON                                                {: RESULT = new AST_STMT_RETURN(e); :}
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	                {: RESULT = new AST_STMT_IF(cond,body); :}
					| WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	            {: RESULT = new AST_STMT_WHILE(cond,body); :}
                    | ID:name LPAREN RPAREN SEMICOLON                                       {: RESULT = new AST_STMT_FUNC_CALL(name); :}
                    | var:v DOT ID:name LPAREN RPAREN SEMICOLON                             {: RESULT = new AST_STMT_FUNC_CALL(name, v); :}
                    | var:v DOT ID:name LPAREN expList:e RPAREN SEMICOLON                   {: RESULT = new AST_STMT_FUNC_CALL(name, e, v); :}
                    | ID:name LPAREN expList:e RPAREN SEMICOLON                             {: RESULT = new AST_STMT_FUNC_CALL(name, e); :}
			;
// endregion

// region utils
cField      ::=     varDec:d                                                                {: RESULT = d; :}
				    | funcDec:d                                                             {: RESULT = d; :}
			;

cFieldList  ::=     cField:d cFieldList:l	                                                {: RESULT = new AST_DEC_LIST(d,l); :}
				    | cField:d				                                                {: RESULT = new AST_DEC_LIST(d,null); :}
			;

idList		::=		ID:type ID:name	COMMA idList:l		                                    {: RESULT = new AST_ID_LIST(type, name ,l);    :}
					| ID:type ID:name				                                        {: RESULT = new AST_ID_LIST(type, name); :}
			;
// endregion
